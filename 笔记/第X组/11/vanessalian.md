汇编语言
几乎可以与机器语言一一对应，且更接近自然语言；

CPU：
执行被编译成为机器语言之后的汇编语言
任务有：从内存获取指令并译码执行、根据指令管理自己的寄存器、根据指令或自己的需要修改内存的内容、响应其他硬件的中断请求

寄存器
位于CPU中，可保存特定长度的数据，有些数据对系统的运行具有特殊意义；
可以被装入数据，在不同的寄存器之间移动这些数据或做类似的事情如四则运算位运算等操作。

通用寄存器
都是32位，ＡＣＤ在保护模式中，可做内存偏移指针
名称	通常情况下	保护模式下	注意
EAX	进行运算	作为内存偏移指针	
EBX	内存偏移指针		
ECX	特定指令的计数		
EDX	作为EAX的溢出寄存器（例如乘、除）		
ESI	在内存操作指令中作为源地址指针使用		这三个寄存器没有对应的8-bit分组。但可以通过SI、DI，BP分别访问他们的低16位。

EDI	通常在内存操作指令中作为目的地址指针使用		
EBP	作为指针,也可以建造堆栈帧来保存函数或过程的局部变量		

段寄存器和选择器                     
实模式的段寄存器到保护模式下就变成了选择器。实模式下的段选择器是16-bit，保护模式下的选择器是32-bit
CS 代码段
	指向当前正在执行的地址	只有在收到跳转指令或其他分支指令后，处理器才能执行
DS 数据段
	指向指令将要执行的内存	所有的内存操作指令默认情况下都用它指定操作段（实模式）或内存（保护模式下作为选择器）。这个寄存器可以通过堆栈可被装入任意数值
ES 附加段
	指向指令将要处理的内存	
FS
	作为默认段寄存器或选择器的一个替代品	
GS
	和FS几乎完全一样	
SS
	指向下一次堆栈操作（push和pop）所要使用的堆栈地	可以被装入任意数值，可通过入栈和出站操作来赋值


特殊寄存器
EIP:32-bit，这个寄存器非常重要，同CS一同指向即将执行的那条指令的地址。不能够直接修改这个寄存器的值，修改它的唯一方法是跳转或分支指令。（ CS是默认的段或选择器）
ESP:32-bit，这个寄存器指向堆栈中即将被操作的那个地址。尽管可以修改它的值，但并不提倡这样做，可能会破坏堆栈。（SS是默认的段或选择器）
IP： Instruction Pointer，指令指针。
SP： Stack Pointer，堆栈指针。

标志寄存器

              控制寄存器：CR0、CR2、CR3
其他寄存器
              调试寄存器：D0、D1、D2、D3、D6和D7

              测试寄存器：TR3、TR4、TR5、TR6、TR
密码学预热

一、数制转换
二进制，八进制，十进制，十六进制的概念以及相互转换
二进制逢二进一,八进制逢八进一,十进制逢十进一，十六进制逢十六进一。
0110 0100(2) 换算成 十进制    
第0位 0 * 2^0  =  0 
第1位 0 * 2^1  =  0 
第2位 1 * 2^2  =  4 
第3位 0 * 2^3  =  0 
第4位 0 * 2^4  =  0 
第5位 1 * 2^5  = 32 
第6位 1 * 2^6  = 64  
第7位 0 * 2^7  =  0     
＋ ---------------------------                 100 

二进制转八进制 
可采用8421法 1010011(2)  
首每三位分割即:    001,010,011 
不足三位采用0补位. 
然后采用8421法: 001=1   010=2   011=3  
所以转换成8进制是123

二进制转十六进制 1101011010100(2) 
首先每四位分割即:    0001,1010,1101,0100 不足四位采用0补位. 
然后采用8421法: 0001:1   1010:A   1101:D   0100:4 
所以转换成十六进制是1AD4

十进制转二进制
10进制数转换成二进制数，这是一个连续除2的过程： 
把要转换的数，除以2，得到商和余数，  
将商继续除以2，直到商为0。
最后将所有余数倒序排列，得到数就是转换结果。

十进制转换八进制  
10进制数转换成八进制数，这是一个连续除8的过程： 
把要转换的数，除以8，得到商和余数， 
将商继续除以8，直到商为0。
最后将所有余数倒序排列，得到数就是转换结果。

十进制转换十六进制  
10进制数转换成十六进制数，这是一个连续除16的过程： 
把要转换的数，除以16，得到商和余数，  
将商继续除以16，直到商为0。
最后将所有余数倒序排列，得到数就是转换结果。

八进制转换二进制 
可采用8421法  把每位分成三个组合数 653(8)
把每位分成三个1，0组合: 6=110    5=101    3=011  最后的转换结果就是110101011 

八进制转换成十进制:    
1507换算成十进制。7 * 8^0 + 0 * 8^1 + 5 * 8^2 + 1 * 8^3 = 839

八进制转换十六进制  
可以借助转化为十进制或者二进制后在进行转换.    

十六进制转换二进制  
每一位拆分为1,0为单位的四位数

十六进制转换为八进制  
可以借助转化为十进制或者二进制后在进行转换. 

十六进制转化为十进制 
2AF5换算成10进制
5 * 160  + F * 161 + A * 162 + 2 * 163 = 10997


二、逻辑运算
与：有0出0；全1出1
或：有1出1；全0出0
非：有1出0；有0出1

三、明码 反码 补码 
1.原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。
2.反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。
3.补码：反码加1称为补码。

四、初识密码学
1.明文，密文，秘钥，公钥，私钥，密钥空间的概念；
明文: 原始的信息，也就是需要被密码保护的信息
密文: 加密是把原始信息转换成不可读形式
秘钥: 是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的数据
私钥: 指加解密的密钥相同或容易推出，因此加解密的密钥都是保密的
公钥: 指加解密密钥彼此无法推出，公钥公开，私钥保密。 
密钥空间: 加密密钥大小的范围。通常以位为单位，即以位的多少来对独特密钥进行计数。密钥的位越长，其密钥空间也就越大
2.凯撒密码:一种代换密码或者移位密码，把所有的字母移动相同位数进行加密和解密
3.简单替换密码:又称单字母密码（monoalphabetic cipher):明文的一个字符用相应的一个密文字符代替，而且密文所用的字符与一般的明文所用字符属同一语言系统
4.换位密码:是一种早期的加密方法，与明文的字母保持相同，区别是顺序被打乱了。
5.分组密码:将明文消息编码表示后的数字（简称明文数字）序列，划分成长度为n的组（可看成长度为n的矢量），每组分别在密钥的控制下变换成等长的输出数字（简称密文数字）序列。
6.对称密码与公钥密码: 加密和解密采用相同的密钥。因为加解密密钥相同，需要通信的双方必须选择和保存他们共同的密钥，各方必须信任对方不会将密钥泄密出去，这样就可以实现数据的机密性和完整性。
7.非对称密码体制也叫公钥加密技术：该技术就是针对私钥密码体制的缺陷被提出来的。在公钥加密系统中，加密和解密是相对独立的，加密和解密会使用两把不同的密钥，加密密钥(公开密钥)向公众公开，谁都可以使用，解密密钥(秘密密钥)只有解密人自己知道，非法使用者根据公开的加密密钥无法推算出解密密钥，顾其可称为公钥密码体制
8.单向散列函数
单向散列函数，又称单向Hash函数、杂凑函数，就是把任意长的输入消息串变化成固定长的输出串且由输出串难以得到输入串的一种函数。这个输出串称为该消息的散列值。一般用于产生消息摘要，密钥加密等，消息认证码，数字签名，
9.数字签名（又称公钥数字签名、电子签章）是一种类似写在纸上的普通的物理签名，但是使用了公钥加密领域的技术实现，用于鉴别数字信息的方法。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。
数字签名，就是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。
数字签名是非对称密钥加密技术与数字摘要技术的应用。
10.数字证书: 就是互联网通讯中标志通讯各方身份信息的一串数字，提供了一种在Internet上验证通信实体身份的方式，数字证书不是数字身份证，而是身份认证机构盖在数字身份证上的一个章或印（或者说加在数字身份证上的一个签名）。它是由权威机构——CA机构，又称为证书授权（Certificate Authority）中心发行的，人们可以在网上用它来识别对方的身份。
11.伪随机数生成器: 用于在系统需要随机数的时候，通过一系列种子值计算出来的伪随机数。因为生成一个真正意义上的“随机数”对于计算机来说是不可能的，伪随机数也只是尽可能地接近其应具有的随机性，但是因为有“种子值”，所以伪随机数在一定程度上是可控可预测的

              

